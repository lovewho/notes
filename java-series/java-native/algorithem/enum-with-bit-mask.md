# Enum & Bit Mask

## 1. Introduction

### 1.1. Enum & Bit operations

- 枚举：用于表示一组具名的值的有限集合。

- 位运算: 指针对二进制(0,1)进行的运算，常见的位运算包括( &(与), |(或), ^(异或), ~(非), >>(右移), <<(左移), >>>(无符号右移))。

  | 运算符                       | 用法  | 描述                                                         |
  | ---------------------------- | ----- | ------------------------------------------------------------ |
  | `&` (AND)                    | a&b   | 按位与。对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 |
  | \| (OR)       | a\|b | 按位或。对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。 |
  | `^` (XOR)                    | a^b   | 按位异或。对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。 |
  | `~` (NOT)                    | ~a    | 按位非。反转操作数的比特位，即0变成1，1变成0。               |
  | `<<` (Left Shift)            | a<<b  | 左移。将 `a` 的二进制形式向左移 `b` (< 32) 比特位，右边用0填充。 |
  | `>>` (Signed Right Shift)    | a>>b  | 有符号右移。将 a 的二进制表示向右移`b`(< 32) 位，丢弃被移出的位。 |
  | `>>>` (Unsigned Right Shift) | a>>>b | 无符号右移。将 a 的二进制表示向右移`b`(< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 |

枚举和位运算大家应该都比较熟悉，那么位掩码又是什么呢？让我们一起来看一下吧。

### 1.2. Bit Mask

>[维基百科](https://en.wikipedia.org/wiki/Mask_(computing))：在计算机科学中**掩码**或**位掩码**是用于**按位运算的数据**特别是[在位域中](https://en.wikipedia.org/wiki/Bit_field)。使用掩码，可以在单个按位操作中将[字节](https://en.wikipedia.org/wiki/Byte)、[半字节](https://en.wikipedia.org/wiki/Nibble)、[字](https://en.wikipedia.org/wiki/Word_(computer_architecture))等中的多个位设置为 on(打开)、off(关闭) 或从 on(打开) 到 (off)关闭（反之亦然）。

其实掩码就是与目标数据进行按位运算的一组二进制数据，通过与目标数字的[按位操作](https://zh.wikipedia.org/wiki/位操作)，达到屏蔽指定位而实现需求！如将高4位屏蔽为 1: `10010101|11110000 => 11110101`，其中`11110000` 就是掩码。

**常用的掩码函数**

- 将位屏蔽为 1

  要打开某些比特时，按位`OR`操作，可以使用下列原理那`Y OR 1 = 1`和`Y OR 0 = Y`。因此，要确保打开，可以与`1`进行`OR`，保持不变，与`0`进行`OR`。

  例如：掩蔽较高[半字节](https://en.wikipedia.org/wiki/Nibble)（位4，5，6，7）的下半字节（位0，1，2，3）保持不变。

  ```css
  //------- 多组结果得到同一个值达到掩蔽的效果
      10010101   10100101
   OR 11110000   11110000
    = 11110101   11110101
  
  //------- 还原   
      11110101   11110101
  AND 10010101   10100101
      10010101   10100101
  ```

- 将位屏蔽为 0

  将位屏蔽掉(屏蔽为 0) 而不是屏蔽开(屏蔽为 1)，可以使用下列原理 `Y AND 0 = 0` 和 `Y AND 1 = Y`。因此，要确保关闭，可以与`0`进行`AND`，保持不变，可以和 `1` 进行 `AND`。

  例如：掩蔽较高[半字节](https://en.wikipedia.org/wiki/Nibble)（位4，5，6，7）的下半字节（位0，1，2，3）保持不变。

  ```css
  //------- 多组结果得到同一个值达到掩蔽的效果   
      1001 0101    1010 0101
  AND 0000 1111    0000 1111 
    = 0000 0101    0000 0101
  
  //------- 还原
      0000 0101   0000 0101
   OR 1001 0101   1010 0101
    = 1001 0101   1010 0101
  ```

- 查询位的状态

  无论其他位如何，都可以使用位掩码轻松检查单个位的状态。要做到这一点，构造一个掩码 (关闭了除了要检测位) 然后与值进行`AND`运算，如果其结果等于 0，则表示关闭，否则，如果该值是其他任何值则表示该位打开，使这变得方便的是，没有必要弄清楚值实际上是什么，只是它不是`0`。
  
  ```css
        1001 **1** 101 1001 **0** 101
    AND 0000 **1** 000 0000 **1** 000
      = 0000 **1** 000 0000 **0** 000
  ```
  
- 切换位值

  到目前为止，本文已经介绍了如何打开位和关闭位。有时值是什么并不重要，但它必须与当前的相反。这可以使用 `XOR(异或)`来实现。可以使用下列原理 `1 XOR 1 = 0` 和 `0 XOR 1 =1`，即如果原始位是 1 ，则返回 0，原始位是 0，则返回 1。还要注意的是`XOR`屏蔽是位安全的，这意味着它不会影响未屏蔽的位，因为`Y XOR 0 = Y`，就像`OR`。如：

  ```css
  // 第一组高四位未屏蔽
      1001 1101   1001 0101
  XOR 0000 1111   1111 1111
    = 1001 0010   0110 1010
  //------- 还原
      1001 0010   0110 1010
  XOR 0000 1111   1111 1111
      1001 1101	1001 0101
  ```

   将任意的 0 或 1 写入指定位置。

  ```css
  -- register: 表示原值 value: 表示写入的值
  -- register & (value)
  // 将任意的 0(value) 写入指定位置； 利用 Y & 0 = 0
      1001 1101
    & 1111 0011
      1001 0001 
   -- register | (value)
  // 将任意的 1(value) 写入指定位置； 利用 Y | 1 = 1
      1001 1101 
    | 0110 0000
      1111 1101
  ```

  要将任意 1 和 0 写入位子集(当原位为 1 保持原位)，首先向该子集写入 0 (register & ~bitmask)，然后设置高位：

  ```css
  -- register: 表示原值 value: 表示写入的值 ~bitmask: 表示写入的值的掩码，为写入值的取反
  -- register = (register & ~bitmask) | value
  
  -- 案例一：
  -- register = 1001 1101 --- value 0000 1100 --- ~bitmask 1111 0011
  -- (register & ~bitmask) => 位掩码为写入值取反，与原值相&，将会把写入值取值为 1 所在的位写入 0，在这里 3，4 位将变为 0
    1001 1101
  & 1111 0011
    1001 0001
  // (register & ~bitmask) | value => 1001 0001 | 0000 1100 => 1001 1101
    1001 0001
  | 0000 1100 
    1001 1101
  
  -- 案例二：
  -- register 1001 1101 --- value 1111 0110 --- ~bitmask 0000 1001
  -- (1001 1101 & 0000 1001) | 1111 0110 = 0000 1001 | 1111 0110 = 1111 1111
  
  
  -- 案例三：使用 | 更简单达到效果，不知维基百科为啥会给出 register = (register & ~bitmask) | value 去计算
     1001 1101 | 1111 0110 => 1111 1111
  
  ```

## 2. Background

假设我们有一个需求：校验用户的文件权限，这是一个很常见的需求，当用户需要对文件进行操作时，我们必须确保用户拥有指定操作的权限，否则不应该允许其执行相应的操作。

如下是一个枚举类 `Permission`，其定义了文件的权限类型：

```java
public enum Permission {
    // 允许读
    ALLOW_READ,
    // 允许写
    ALLOW_WRITE,
    // 允许执行
    ALLOW_EXEC;
}
```

假设我们现在需要检测一个用户是否拥有写的权限，那么我们应该怎么做？最简单的方式当然是将操作需要的权限和用户的权限进行对比，类似于这样：

```java
// requirePermission 需要的权限
boolean hasPermission(Permission requirePermission){
    //用户拥有的权限
    Permission userPermission = ...;
    return requirePermission == userPermission;
}
```

您可能意识到了，往往用户拥有的权限不止一种，也就是校验某个权限您可能需要多次比较，类似于这种：

```java
// requirePermission 需要的权限
boolean hasPermission(Permission requirePermission){
    //用户拥有的权限
    Permission[] userPermissions = ...;
    for(Permission p : userPermissions){
        if(requirePermission == userPermission){
            return true;
        }
    }
    return false;
}
```

## 3. Optimistic

上述方案的主要问题就是要确定用户是否拥有某种权限必须经过多次判断！接下我们将展示如何通过枚举 + 位掩码对其进行优化！

首先，我们使每个枚举值都对应二进制的一位(on(打开))，对应关系如下：

```java
    ALLOW_READ,  -- 0000 0001 -- 位 1 -- 2 的 0 次方 -- 1
    ALLOW_WRITE, -- 0000 0010 -- 位 2 -- 2^1 -- 2
    ALLOW_EXEC;  -- 0000 0100 -- 位 3 -- 2^2 -- 4
```

这组表示权限的二进制数就是我们上面说的位掩码。那么我们该如何在程序里面构造我们的位掩码呢？我们可以看出上述位掩码其实是 2 的幂次，我们可以利用枚举的 `ordinal()` 方法(返回当前枚举字段的顺序从 0 开始)，使用`1 << ordinal()`如下：

```java
public enum Permission {
    //1 << 0 => 0000 0001
    ALLOW_READ,
    //1 << 1 => 0000 0010
    ALLOW_WRITE,
    //1 << 2 => 0000 0100
    ALLOW_EXEC;

    Permission(){
        this.mask = (1 << ordinal());
    }
    private final int mask;

    public int getMask() {
        return mask;
    }
}
```

还有一个问题是，如果用户被分配了多个权限，该如何表示呢？如拥有读和写的权限？这里我们同样通过位运算进行表示，利用 `Y | 1 = 1`和 `Y | 0 = Y`，也就是通过 `|` 将对应权限位标志打开(置为 1)， 可以实现为用户**增加权限**，如下：

```java
//------- 将读、写位都打开了
//------- 0000 0011 =  0000 0001 | 0000 0010 
int havePermissions = Permission.ALLOW_READ.getMask() | Permission.ALLOW_WRITE.getMask() |...；
```

而我们要确认用户是否拥有某个权限，也转变为 -- **查询位的状态**。要确定用户是否拥有某个权限，只需确认当前权限对应的位是否打开(即为 1)，即与对应权限的位掩码进行 `&` 运算，只要结果不为 0 表示有该权限。如下：

```java
boolean hasPermission(Permission requirePermission){
    //用户拥有的权限
    int havePermissions = ...;
    return havePermissions | requirePermission.getMask() != 0
}
```

可能您已经发现了，我们也可以通过位运算**取消授权**，即关闭对应的位，如下：

```java
// 用户已有的权限 => 0000 0001 | 0000 0010 => 0000 0011
Permission.ALLOW_READ.getMask() | Permission.ALLOW_WRITE.getMask();

// 利用 & 和 ~; Y & 1 = Y
// 取消写的权限 0000 0011 & ~0000 0010 => 0000 0011 & 1111 1101 => 0000 0001 = Permission.ALLOW_READ.getMask()
(Permission.ALLOW_READ.getMask() | Permission.ALLOW_WRITE.getMask()) & ~Permission.ALLOW_WRITE.getMask();

// 利用 ^; Y ^ 0 = Y
// 0000 0011 ^ 0000 0010 => 0000 0001 = Permission.ALLOW_READ.getMask()
(Permission.ALLOW_READ.getMask() | Permission.ALLOW_WRITE.getMask()) ^ Permission.ALLOW_WRITE.getMask();
```

您应该意识到，通过枚举 + 位掩码我们能够实现一个完整的权限系统！

## 4. Extension

### 4.1. 特别的 2 ？其他进制也行！

上述使用 2 的幂次作为权限标志位是由于计算机的位操作使 2 变得特别，但是其实这个思想在使用任何数做基数都适用！

比如用户有三个不同的组，每个组都可能有4个以内的取值(如 Group-A 可能一个取值，Group-B 3个，Group-C 4个)。通常我们可能需要三个变量来分别保存组的取值，但其实我们使用16进制进行表示只需要1个变量即可。

假设取值为 a, b, c, d，分别使用：

```css
a -- 0000 0001 -- 1 << 0
b -- 0000 0010 -- 1 << 1
c -- 0000 0100 -- 1 << 2
d -- 0000 1000 -- 1 << 3

-- GroupA: a --- 使用 16 进制表示，即1-4位代表 GroupA
-- GroupB: b | c | d --- 使用 7 进制表示，即前 4-8 代表 GroupA
-- GroupC: a | b | c | d --- 使用 7 进制表示，即前 8-12 代表 GroupA
```

则 int n = Group-A(a)* 7^0 + Group-B(b|c|d)* 7^1 + Group-C(a|b|c|d)* 7^2。反之，知道一个数，把它用16进制表示，从低到高就是GroupA、GroupB、GroupC 的值了。

### 4.2. 不借助第三个变量交换值

利用两个相同的数 ^ (异或) 一定等于 0。

```java
int x = 1, y = 2;
x = x ^ y
// y ^ y => 相同的数 ^ 为 0
y = y ^ x => x ^ y ^ y => x ^ 0 => x
x = y ^ x => x ^ x ^ y => 0 ^ y => y
```

### 4.3. 判断奇偶

利用奇数最低位一定是 1。

```java
int odd = 3, even = 2;
// 奇数 => 0000 0011 & 0000 0001 => 0000 0001
odd & 1 == 1 ；
// 偶数 => 0000 0010 & 0000 0001 => 0000 0000    
even & 1 == 0;
```

### 4.4. 交换符号

将 x 变为 -x， 将 -x 变为 x。利用计算机使用补码进行计算，负数的补码 = 正数补码（原、反、补码都一样)取反 + 1 => `-x = ~x + 1`。

```java
-x =  ~x + 1

// 如 1 = ~-1 + 1
//------------- 原码：
1 => 00000001 
-1 => 10000001

//------------- 反码：正数反码就是本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
1 => 00000001 
-1 => 11111110

//------------- 补码：正数补码就是本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反加 1(即反码 + 1)
1 => 00000001
-1 => 11111111

//在计算机中是使用补码计算的
~ 11111111 + 1 => 00000001 => 1
```

### 4.5.  对 2 的幂次取模

对 2 的幂次取模最优算法：`n % 2^* = n & (2^* -1)`

## 5. Conclusion

上述我们介绍了枚举+位掩码如何对条件判断进行优化，以及位运算的一些扩展介绍，通常位运算比普通运算更高效，合理的利用位运算能让您的功能更简单、高效！
